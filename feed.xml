<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>YK</title>
    <description>YK's Blog.
</description>
    <link>https://shiyk.dev/</link>
    <atom:link href="https://shiyk.dev/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 04 Aug 2020 21:18:56 +0800</pubDate>
    <lastBuildDate>Tue, 04 Aug 2020 21:18:56 +0800</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title>在Jekyll中使用highlight.js</title>
        <description>&lt;p&gt;最近想把网站的代码高亮从Jekyll默认的Rouge换成highlight.js，本来以为会很麻烦，没想到简单搜索了一下却发现其实只需要短短几步&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;禁用Rouge&lt;/p&gt;

    &lt;p&gt;在_config.yml里添加以下代码&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-yml&quot;&gt;markdown: kramdown
kramdown:
  syntax_highlighter_opts:
    disable: true
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;引入highlight.js&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;/path/to/styles/default.css&quot;&amp;gt;
&amp;lt;script src=&quot;/path/to/highlight.pack.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启用highlight.js&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;hljs.initHighlightingOnLoad();
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;highlight.js默认会高亮所有&lt;code class=&quot;html&quot;&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;...&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/code&gt;标签内的代码，正好kramdown也会把代码块里的代码放在&lt;code class=&quot;html&quot;&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;...&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/code&gt;里面，所以不需要特别配置。不过inline代码外面就只有&lt;code class=&quot;html&quot;&gt;&amp;lt;code&amp;gt;...&amp;lt;/code&amp;gt;&lt;/code&gt;标签，所以如果想要高亮inline代码的话，就不能用直接用默认配置启动了。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;修改highlight.js的启动代码：&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;javascript&quot;&gt;hljs.initHighlightingOnLoad()&lt;/code&gt;相当于以下代码：&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;document.addEventListener('DOMContentLoaded', (event) =&amp;gt; {
  document.querySelectorAll('pre code').forEach((block) =&amp;gt; {
    hljs.highlightBlock(block);
  });
});
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;要高亮inline代码的，需要把&lt;code class=&quot;javascript&quot;&gt;hljs.initHighlightingOnLoad()&lt;/code&gt;改为：&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;document.addEventListener('DOMContentLoaded', (event) =&amp;gt; {
  document.querySelectorAll('code').forEach((code) =&amp;gt; {
    hljs.highlightBlock(code);
  });
});
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加css代码&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;javascript&quot;&gt;hljs.highlightBlock(code);&lt;/code&gt;会给&lt;code class=&quot;html&quot;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;标签添加&lt;code class=&quot;code&quot;&gt;.hljs&lt;/code&gt;，这个css类会让&lt;code class=&quot;html&quot;&gt;&amp;lt;code&amp;gt;&lt;/code&gt;以block显示：&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.hljs {
    display:block;
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;添加以下css，让inline代码行内显示：&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;pre code.hljs {
  display: block;
}
   
code.hljs {
  display: inline;
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;值得一提的是，highlight.js是通过&lt;code&gt;&amp;lt;code class=&quot;javascript&quot;&amp;gt;&lt;/code&gt;中的class确定代码语言的，如果简单的写两个反引号的话（如&lt;code&gt;`some codes`&lt;/code&gt;），因为没有相关的CSS类，highlight.js就只能靠猜了。好在kramdown可以用这种写法指定语言：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plaintext&quot;&gt;`Redcarpet.new(&quot;Hello World!&quot;)`{:.ruby}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你用的是pandoc的话，那就是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-plaintext&quot;&gt;`Redcarpet.new(&quot;Hello World!&quot;)`{.ruby}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完工！&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Mar 2019 21:36:00 +0800</pubDate>
        <link>https://shiyk.dev/posts/Jekyll-highlightjs/</link>
        <guid isPermaLink="true">https://shiyk.dev/posts/Jekyll-highlightjs/</guid>
        
        <category>Bloging</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>给静态博客添加页面切换效果</title>
        <description>&lt;p&gt;经常折腾各种静态博客主题的同学可能会发现，大多数主题都没有添加页面间的切换效果。对于现在流行的单页应用，添加过渡效果并不是什么难事；但是对于静态博客来说，每次页面切换都是要刷新整个页面的“硬刷新”，想要添加切换效果就比较麻烦了。这篇文章里我使用了一个可能有点“过时”但意外的好用的方法来解决这个问题，它就是：&lt;a href=&quot;https://github.com/defunkt/jquery-pjax&quot;&gt;PJAX&lt;/a&gt;。&lt;/p&gt;

&lt;!-- read more --&gt;

&lt;h3 id=&quot;1-pjax与barbajs&quot;&gt;1. PJAX与Barba.js&lt;/h3&gt;

&lt;p&gt;简单来说，PJAX就是PushState + Ajax，它通过这么几个步骤来避免页面的“硬刷新”：阻止点击链接时的正常行为（页面跳转）；通过ajax读取新页面；手动更改地址栏的URL并将新的内容注入到页面中。常用的PJAX实现有&lt;a href=&quot;https://github.com/defunkt/jquery-pjax&quot;&gt;jquery-pjax&lt;/a&gt;，以及我用到的&lt;a href=&quot;http://barbajs.org/index.html&quot;&gt;Barba.js&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;下面是Barba.js在用户点击链接时执行的操作：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;用户点击链接时，Barba.js会：&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;检查链接是否有效，是否支持ajax。如果是的话，阻止链接的正常行为&lt;/li&gt;
    &lt;li&gt;使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/History/pushState&quot;&gt;push state API&lt;/a&gt;更改页面URL&lt;/li&gt;
    &lt;li&gt;通过XMLHttpRequest获取新页面&lt;/li&gt;
    &lt;li&gt;创建一个新的&lt;a href=&quot;http://barbajs.org/transition.html&quot;&gt;transition&lt;/a&gt;实例&lt;/li&gt;
    &lt;li&gt;新页面加载完成后，barba.js解析新的HTML（取得其中的&lt;code class=&quot;css&quot;&gt;.barba-container&lt;/code&gt;），并将其中的内容插入到&lt;code class=&quot;css&quot;&gt;#barba-wrapper&lt;/code&gt;元素的DOM中。&lt;/li&gt;
    &lt;li&gt;transition实例会负责隐藏旧的container并显示新的container&lt;/li&gt;
    &lt;li&gt;trainsition结束后，旧的container会被移除&lt;/li&gt;
  &lt;/ol&gt;

&lt;/blockquote&gt;

&lt;p&gt;以上摘自Barba.js官网对自己的介绍。看不懂的话没关系（尤其是关于transition的部分），后面我会详细解释，现在我们先来看个示例。&lt;/p&gt;

&lt;h2 id=&quot;2-quickstart&quot;&gt;2. QuickStart&lt;/h2&gt;

&lt;h3 id=&quot;21-安装&quot;&gt;2.1 安装&lt;/h3&gt;

&lt;p&gt;barba.js 支持 AMD, CommonJS 和 Browser global (使用 &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;)。&lt;/p&gt;

&lt;p&gt;可以通过npm安装：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;npm install barba.js --save-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者直接在页面里引入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script src=&quot;barba.min.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想让barba.js正常工作的话，还得给它一点页面结构的信息。通常在页面里加入这么个结构就可以了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div id=&quot;barba-wrapper&quot;&amp;gt;
  &amp;lt;div class=&quot;barba-container&quot;&amp;gt;
    ...Put here the content you wish to change between pages...
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在页面里初始化Barba.js：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//Please note, the DOM should be ready
Barba.Pjax.start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是不是挺简单的？下面我们就自己动手试一试。&lt;/p&gt;

&lt;h3 id=&quot;22-简单尝试&quot;&gt;2.2 简单尝试&lt;/h3&gt;

&lt;p&gt;以我使用的Jekyll主题为例，这是我的页面的基本布局：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;
&amp;lt;html lang=&quot;{{ site.lang }}&quot;&amp;gt;

  {% include head.html %}
  
  &amp;lt;body&amp;gt;
    
    {% include header.html %}
    {% include aside.html %}
      
    &amp;lt;main class=&quot;content-wrapper&quot;&amp;gt;
      {{ content }}
    &amp;lt;/main&amp;gt;
    
    {% include footer.html %}
    
    &amp;lt;script&amp;gt;
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里head.html、header.html、footer.html的内容在所有页面都是一样的，会发生变化的是aside.html和content。所以我们要做的就是把aside.html和content用&lt;code class=&quot;css&quot;&gt;#barba-wrapper&lt;/code&gt;和&lt;code class=&quot;css&quot;&gt;.barba-container&lt;/code&gt;包起来，然后在在script中执行&lt;code class=&quot;javascript&quot;&gt;Barba.Pjax.start();&lt;/code&gt;。当然，不要忘记在head.html中引入barba.js。修改后的布局是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;html lang=&quot;{{ site.lang }}&quot;&amp;gt;

  {% include head.html %}
  
  &amp;lt;body&amp;gt;
    {% include header.html %}
    
    &amp;lt;div id=&quot;barba-wrapper&quot;&amp;gt;
      &amp;lt;div class=&quot;barba-container&quot;&amp;gt;
        {% include aside.html %}
        &amp;lt;main class=&quot;content-wrapper&quot;&amp;gt;
          {{ content }}
        &amp;lt;/main&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    
    {% include footer.html %}
    
    &amp;lt;script&amp;gt;
        Barba.Pjax.start();
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以了。打开浏览器的网络面板，点击任意链接，可以看到网络请求类型变成了xhr（XMLHttpRequest），请求的发起者也变成了barba.js：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/switch-page-with-pjax/pjax-load-page.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，当我们点击页面上的链接的时候，barba.js会用ajax加载目标页面，加载完成后，会用新页面里的&lt;code class=&quot;css&quot;&gt;.barba-container&lt;/code&gt;元素替换旧的&lt;code class=&quot;css&quot;&gt;.barba-container&lt;/code&gt;。做到这些一共只需要5行代码，很简单吧？&lt;/p&gt;

&lt;h2 id=&quot;3-深入一点&quot;&gt;3. 深入一点&lt;/h2&gt;

&lt;p&gt;我们的初衷是给页面添加切换效果，要做到这点需要对barba.js的&lt;code class=&quot;javascript&quot;&gt;transition&lt;/code&gt;有所了解。&lt;code class=&quot;javascript&quot;&gt;transition&lt;/code&gt;是barba.js里负责隐藏旧容器、显示新容器的对象。在&lt;a href=&quot;#1-pjax与barbajs&quot;&gt;第1节&lt;/a&gt;里我们介绍过barba.js的工作流程，其中需要特别解释的是第5步、第6步和第7步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;第5步&lt;/p&gt;

    &lt;p&gt;当ajax加载新页面完成后，barba.js会从新页面中找到&lt;code class=&quot;css&quot;&gt;.barba-container&lt;/code&gt;元素，并把它插入到&lt;code class=&quot;css&quot;&gt;#barba-wrapper&lt;/code&gt;元素中。这时候在页面的&lt;code class=&quot;css&quot;&gt;#barba-wrapper&lt;/code&gt;元素下，会有两个&lt;code class=&quot;css&quot;&gt;.barba-container&lt;/code&gt;元素，barba.js会给新插入的那个添加一个&lt;code class=&quot;css&quot;&gt;visibility: hidden;&lt;/code&gt;，把它隐藏起来。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第6步&lt;/p&gt;

    &lt;p&gt;现在就轮到&lt;code class=&quot;javascript&quot;&gt;transition&lt;/code&gt;出场了。它需要负责把两个&lt;code class=&quot;css&quot;&gt;.barba-container&lt;/code&gt;中的旧的那个隐藏起来，并把新的那个显示出来。这个显示和隐藏的过程，就是我们添加切换效果的地方。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第7步&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;javascript&quot;&gt;transition&lt;/code&gt;完成切换后，barba.js会把旧的那个&lt;code class=&quot;css&quot;&gt;.barba-container&lt;/code&gt;移除掉，这样整个流程就完成了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体实现上，我们只要自定义一个继承了&lt;a href=&quot;https://github.com/luruke/barba.js/blob/master/src/Transition/BaseTransition.js&quot;&gt;Barba.BaseTransition&lt;/a&gt;的&lt;code class=&quot;javascript&quot;&gt;transition&lt;/code&gt;对象，并把它配置到barba.js里就可以了。&lt;code class=&quot;javascript&quot;&gt;BaseTransition&lt;/code&gt;有这么几个成员：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Member&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;start&lt;/td&gt;
      &lt;td&gt;transition开始的时候会自动调用这个函数。（你可以把它当做transition的构造函数）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;done&lt;/td&gt;
      &lt;td&gt;transition完成后，调用这个函数通知barba.js进行后续工作。&lt;strong&gt;千万别忘记调用这个函数！&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;oldContainer&lt;/td&gt;
      &lt;td&gt;旧容器的HTMLElement&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;newContainerLoading&lt;/td&gt;
      &lt;td&gt;加载新容器的Promise&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;newContainer&lt;/td&gt;
      &lt;td&gt;新容器的HTMLElement(带有 &lt;code class=&quot;css&quot;&gt;visibility: hidden;&lt;/code&gt;) &lt;strong&gt;注意，在newContainerLoading 完成前这个变量都是undefined！&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;barba.js的默认transition是HideShowTransition，这个transition很简单，我们自己来重新实现一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var HideShowTransition = Barba.BaseTransition.extend({
  start: function() {
    this.newContainerLoading.then(this.finish.bind(this));
  },

  finish: function() {
    document.body.scrollTop = 0;
    this.done();
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，把它设置给barba.js:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;Barba.Pjax.getTransition = function() {
  return HideShowTransition;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看完这个例子，实现页面切换效果的方法也就呼之欲出了。只要修改&lt;code&gt;finish&lt;/code&gt;函数，把旧容器淡出，新容器淡入就可以了。barba.js官方给出了一个淡入淡出的transition示例，这个例子使用了jQuery的&lt;code class=&quot;javascript&quot;&gt;.animate()&lt;/code&gt;，不过barba.js并不依赖jQuery，你也完全可以用其他JS库、原生javascript或CSS来实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var FadeTransition = Barba.BaseTransition.extend({
  start: function() {
    /**
     * This function is automatically called as soon the Transition starts
     * this.newContainerLoading is a Promise for the loading of the new container
     * (Barba.js also comes with an handy Promise polyfill!)
     */

    // As soon the loading is finished and the old page is faded out, let's fade the new page
    Promise
      .all([this.newContainerLoading, this.fadeOut()])
      .then(this.fadeIn.bind(this));
  },

  fadeOut: function() {
    /**
     * this.oldContainer is the HTMLElement of the old Container
     */

    return $(this.oldContainer).animate({ opacity: 0 }).promise();
  },

  fadeIn: function() {
    /**
     * this.newContainer is the HTMLElement of the new Container
     * At this stage newContainer is on the DOM (inside our #barba-container and with visibility: hidden)
     * Please note, newContainer is available just after newContainerLoading is resolved!
     */

    var _this = this;
    var $el = $(this.newContainer);

    $(this.oldContainer).hide();

    $el.css({
      visibility : 'visible',
      opacity : 0
    });

    $el.animate({ opacity: 1 }, 400, function() {
      /**
       * Do not forget to call .done() as soon your transition is finished!
       * .done() will automatically remove from the DOM the old Container
       */

      _this.done();
    });
  }
});

/**
 * Next step, you have to tell Barba to use the new Transition
 */

Barba.Pjax.getTransition = function() {
  /**
   * Here you can use your own logic!
   * For example you can use different Transition based on the current page or link...
   */

  return FadeTransition;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;4-一点小trick&quot;&gt;4. 一点小trick&lt;/h2&gt;

&lt;p&gt;对有背景图片的页面，切换到新页面后如果图片加载比较慢的话，还是会出现图片刷新的问题。通常我们会用一个固定的淡入效果来掩盖刷新过程，不过有了barba.js，我们可以做的更优雅一点。主要思路是，页面切换的时，不再FadeTransition那样隐藏旧容器显示新容器，而是把新容器里改变了的元素覆盖到旧容器里去。&lt;/p&gt;

&lt;p&gt;还是以我的jekyll主题为例，我的页面背景是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div class=&quot;cover-image&quot; style=&quot;background-image: url(/path/to/background)&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对它做一点小修改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div class=&quot;cover-image&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;cover-image cover-image-on&quot; style=&quot;background-image: url(/path/to/background)&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后加入CSS：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.cover-image {
  opacity: 0;
  transition: opacity .4s ease-in-out
}

.cover-image-on {
  opacity: 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自定义trasition:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var OverwriteTransition = Barba.BaseTransition.extend({
    start: function() {
        this.newContainerLoading.then(this.switch.bind(this));
    },
  
    switch: function() {
        
        var $newContainer = $(this.newContainer);
        var $oldContainer = $(this.oldContainer);
        
        // 找到新背景图片URL
        var newCoverBg = $newContainer.find('.cover-image-on').css('background-image');
      
        /* 
        更新背景
        这里有两个.cover-image，带有.cover-image-on的是旧页面的背景，
        我们把新页面的背景设置到另一个里面去
        然后用imagesLoaded这个jQuery插件监视它的状态
        当新背景图片加载完成时，就通过增删.cover-image-on把旧的背景隐藏掉，新的显示出来
        */
        $oldContainer.find('.cover-image:not(.cover-image-on)').css('background-image', newCoverBg);
        $oldContainer.find('.cover-image:not(.cover-image-on)').addClass('cover-image-switch');
        $oldContainer.find('.cover-image-switch').imagesLoaded(
            {background: true},
            function() {
                $(&quot;.cover-image-on&quot;).removeClass(&quot;cover-image-on&quot;);
                $(&quot;.cover-image-switch&quot;).addClass(&quot;cover-image-on&quot;);
                $(&quot;.cover-image-switch&quot;).removeClass(&quot;cover-image-switch&quot;);
            }
        );

        // 同样的，新的页面内容也需要覆盖到旧容器里去
        // ...
        
        // scroll to top
        $(&quot;html, body&quot;).animate({ scrollTop: 0 }, 0);

        /*
        新container的内容已经覆盖到旧container里了
        所以交换transition里的两个container
        让barba.js销毁新容器，保留旧容器
        */
        var _new = this.newContainer;
        this.newContainer = this.oldContainer;
        this.oldContainer = _new;
        this.swapContainer.bind(this)();

        // done        
        this.done();
    }
});

  
Barba.Pjax.getTransition = function() {
    return OverwriteTransition;
};
Barba.Pjax.start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/switch-page-with-pjax/pjax-load-background.gif&quot; alt=&quot;图片加载效果&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;5-就到这里吧&quot;&gt;5. 就到这里吧&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://barbajs.org/index.html&quot;&gt;barba.js&lt;/a&gt;还提供了很多好用的功能，包括Views、缓存、预加载等，感兴趣的同学可以到他们的网站上去详细了解。&lt;/p&gt;

&lt;p&gt;上一节里两个&lt;code class=&quot;css&quot;&gt;.cover-image&lt;/code&gt;互相切换的方法借鉴了&lt;a href=&quot;https://journal.jekyllthemes.io/&quot;&gt;journal&lt;/a&gt;这个主题的实现，致敬！&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Dec 2018 23:11:00 +0800</pubDate>
        <link>https://shiyk.dev/posts/switch-page-with-pjax/</link>
        <guid isPermaLink="true">https://shiyk.dev/posts/switch-page-with-pjax/</guid>
        
        <category>Bloging</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>一起来写个简单的解释器（8）</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本文是&lt;a href=&quot;https://ruslanspivak.com/&quot;&gt;Ruslan Spivak&lt;/a&gt;的《一起来写个简单的解释器》系列的第8篇（&lt;a href=&quot;/posts/lsbasi-part7&quot;&gt;第7篇&lt;/a&gt;）。&lt;br /&gt;
如果你对kotlin感兴趣，可以参考我的&lt;a href=&quot;https://github.com/shiyk/spi-kotlin/tree/part8&quot;&gt;spi-kotlin&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;今天我们要学习两种一元操作符：一元加(+)和一元减(-)。&lt;/p&gt;

&lt;p&gt;今天的很多内容都是以上一篇文章为基础的。如果&lt;a href=&quot;/posts/lsbasi-part7&quot;&gt;上一章&lt;/a&gt;的有些内容你已经记不清了，可以先回去复习一下。记住：重复是学习之母。&lt;/p&gt;

&lt;p&gt;闲话少说，今天你会学到：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;扩展语法，增加对一元加和一元减的支持&lt;/li&gt;
  &lt;li&gt;增加新的 &lt;em&gt;UnaryOp&lt;/em&gt; AST节点类&lt;/li&gt;
  &lt;li&gt;扩展分析器，支持 &lt;em&gt;UnaryOp&lt;/em&gt; 类型的AST节点&lt;/li&gt;
  &lt;li&gt;扩展翻译器，增加新的visit_UnaryOp方法来处理一元操作符&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开始吧？&lt;/p&gt;

&lt;p&gt;到目前为止我们处理的都是二元操作符(+, -, *, /)，也就是操作两个操作数的操作符。那么一元操作符是什么呢？&lt;em&gt;一元操作符&lt;/em&gt; 是只操作一个操作数的操作符。一元加和一元减操作符的运算规则如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;一元减操作符的结果是它的操作数的相反数&lt;/li&gt;
  &lt;li&gt;一元加操作符的结果是它的操作数自身&lt;/li&gt;
  &lt;li&gt;一元操作符的优先级高于二元操作符 (加减乘除）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在表达式“+ - 3”中，第一个操作符“+”表示一元加操作，第二个操作符“-”表示一元减操作。表达式“+ - 3”等价于“+(-(3))”，也就是-3。你也可以把表达式里的-3看做一个负数，不过在这篇文章里我们把它当做一个一元减操作符和一个正数3：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part8/lsbasi_part8_exp1.png&quot; alt=&quot;exp1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再来看另一个表达式，“5 - - 2”：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part8/lsbasi_part8_exp2.png&quot; alt=&quot;exp2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在表达式“5 - - 2”里，第一个“-”表示&lt;strong&gt;二元&lt;/strong&gt;减操作符，第二个“-”表示&lt;strong&gt;一元&lt;/strong&gt;减操作符。&lt;/p&gt;

&lt;p&gt;下面是更多的例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part8/lsbasi_part8_exp3.png&quot; alt=&quot;exp3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part8/lsbasi_part8_exp4.png&quot; alt=&quot;exp4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，我们要升级语法规则，来支持一元加和一元减操作符。首先先修改 &lt;em&gt;factor&lt;/em&gt; 规则，在其中添加一元操作符。把一元操作符加在 factor 规则里是因为它的优先级要高于二元操作符（加减乘除）。&lt;/p&gt;

&lt;p&gt;现在 &lt;em&gt;factor&lt;/em&gt; 的规则从这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part8/lsbasi_part8_factor_before.png&quot; alt=&quot;factor_before&quot; /&gt;&lt;/p&gt;

&lt;p&gt;变成了这个样子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part8/lsbasi_part8_factor_after.png&quot; alt=&quot;factor_before&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，&lt;em&gt;factor&lt;/em&gt; 规则引用了自己，这样 factor 就能扩展出像“- - - + - 3”这样的表达式了。&lt;/p&gt;

&lt;p&gt;下面是现在的完整语法规则：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part8/lsbasi_part8_grammar.png&quot; alt=&quot;factor_before&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下一步是增加表示一元操作符的AST节点类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class UnaryOp(AST):
    def __init__(self, op, expr):
        self.token = self.op = op
        self.expr = expr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;构造器接收两个参数：&lt;em&gt;op&lt;/em&gt; 表示一元操作符的token（加或减），&lt;em&gt;expr&lt;/em&gt; 表示一个AST节点。&lt;/p&gt;

&lt;p&gt;升级后的语法规则中， &lt;em&gt;factor&lt;/em&gt; 规则发生了变化，所以我们的分析器中的相应方法 &lt;em&gt;factor&lt;/em&gt; 也需要进行修改，增加代码来处理“(PLUS | MINUS) factor”这条子规则。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def factor(self):
    &quot;&quot;&quot;factor : (PLUS | MINUS) factor | INTEGER | LPAREN expr RPAREN&quot;&quot;&quot;
    token = self.current_token
    if token.type == PLUS:
        self.eat(PLUS)
        node = UnaryOp(token, self.factor())
        return node
    elif token.type == MINUS:
        self.eat(MINUS)
        node = UnaryOp(token, self.factor())
        return node
    elif token.type == INTEGER:
        self.eat(INTEGER)
        return Num(token)
    elif token.type == LPAREN:
        self.eat(LPAREN)
        node = self.expr()
        self.eat(RPAREN)
        return node
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来扩展 &lt;em&gt;Interpreter&lt;/em&gt; 类，增加 &lt;em&gt;visit_UnaryOp&lt;/em&gt; 方法来翻译一元节点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def visit_UnaryOp(self, node):
    op = node.op.type
    if op == PLUS:
        return +self.visit(node.expr)
    elif op == MINUS:
        return -self.visit(node.expr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;继续前进！&lt;/p&gt;

&lt;p&gt;我们先手工构建表达式“5 - - - 2”的AST，把它传给解释器，来验证一下我们的 &lt;em&gt;visit_UnaryOp&lt;/em&gt; 方法。你可以在Python shell里这样测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; from spi import BinOp, UnaryOp, Num, MINUS, INTEGER, Token
&amp;gt;&amp;gt;&amp;gt; five_tok = Token(INTEGER, 5)
&amp;gt;&amp;gt;&amp;gt; two_tok = Token(INTEGER, 2)
&amp;gt;&amp;gt;&amp;gt; minus_tok = Token(MINUS, '-')
&amp;gt;&amp;gt;&amp;gt; expr_node = BinOp(
...     Num(five_tok),
...     minus_tok,
...     UnaryOp(minus_token, UnaryOp(minus_token, Num(two_tok)))
... )
&amp;gt;&amp;gt;&amp;gt; from spi import Interpreter
&amp;gt;&amp;gt;&amp;gt; inter = Interpreter(None)
&amp;gt;&amp;gt;&amp;gt; inter.visit(expr_node)
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面生成的AST树长这样：
&lt;img src=&quot;/assets/images/lsbasi-part8/lsbasi_part8_ast.png&quot; alt=&quot;lsbasi_part8_ast&quot; /&gt;&lt;/p&gt;

&lt;p&gt;直接从&lt;a href=&quot;https://github.com/rspivak/lsbasi/blob/master/part8/python/spi.py&quot;&gt;GitHub&lt;/a&gt;下载完整的解释器代码，试试更新后的解释器能不能正确求解包含一元运算符的数学表达式。&lt;/p&gt;

&lt;p&gt;下面是一些测试用例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;$ python spi.py
spi&amp;gt; - 3
-3
spi&amp;gt; + 3
3
spi&amp;gt; 5 - - - + - 3
8
spi&amp;gt; 5 - - - + - (3 + 4) - +2
10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我也更新了&lt;a href=&quot;https://github.com/rspivak/lsbasi/blob/master/part8/python/genastdot.py&quot;&gt;genastdot.py&lt;/a&gt;工具，现在它能处理一元操作符了。下面是一些生成含有一元操作符的表达式的AST图的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;$ python genastdot.py &quot;- 3&quot; &amp;gt; ast.dot &amp;amp;&amp;amp; dot -Tpng -o ast.png ast.dot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part8/lsbasi_part8_genastdot_01.png&quot; alt=&quot;lsbasi_part8_genastdot_01&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;$ python genastdot.py &quot;+ 3&quot; &amp;gt; ast.dot &amp;amp;&amp;amp; dot -Tpng -o ast.png ast.dot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part8/lsbasi_part8_genastdot_02.png&quot; alt=&quot;lsbasi_part8_genastdot_02&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;$ python genastdot.py &quot;5 - - - + - 3&quot; &amp;gt; ast.dot &amp;amp;&amp;amp; dot -Tpng -o ast.png ast.dot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part8/lsbasi_part8_genastdot_03.png&quot; alt=&quot;lsbasi_part8_genastdot_03&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;$ python genastdot.py &quot;5 - - - + - (3 + 4) - +2&quot; \
  &amp;gt; ast.dot &amp;amp;&amp;amp; dot -Tpng -o ast.png ast.dot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part8/lsbasi_part8_genastdot_04.png&quot; alt=&quot;lsbasi_part8_genastdot_04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;给你留个小练习：
&lt;img src=&quot;/assets/images/lsbasi-part8/lsbasi_part8_exercises.png&quot; alt=&quot;lsbasi_part8_exercises&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;安装&lt;a href=&quot;http://www.freepascal.org/&quot;&gt;Free Pascal&lt;/a&gt;，编译并运行&lt;a href=&quot;https://github.com/rspivak/lsbasi/blob/master/part8/python/testunary.pas&quot;&gt;testunary.pas&lt;/a&gt;，检查结果是否与&lt;a href=&quot;https://github.com/rspivak/lsbasi/blob/master/part8/python/spi.py&quot;&gt;spi&lt;/a&gt;生成的结果一致。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;
下面是我推荐的一些书籍列表，它们对你学习解释器和编译器有帮助：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.com/gp/product/193435645X/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=193435645X&amp;amp;linkCode=as2&amp;amp;tag=russblo0b-20&amp;amp;linkId=MP4DCXDV6DJMEJBL&quot;&gt;Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages (Pragmatic Programmers)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.amazon.com/gp/product/0470177071/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0470177071&amp;amp;linkCode=as2&amp;amp;tag=russblo0b-20&amp;amp;linkId=UCLGQTPIYSWYKRRM&quot;&gt;Writing Compilers and Interpreters: A Software Engineering Approach&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.amazon.com/gp/product/052182060X/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=052182060X&amp;amp;linkCode=as2&amp;amp;tag=russblo0b-20&amp;amp;linkId=ZSKKZMV7YWR22NMW&quot;&gt;Modern Compiler Implementation in Java&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.amazon.com/gp/product/1461446988/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=1461446988&amp;amp;linkCode=as2&amp;amp;tag=russblo0b-20&amp;amp;linkId=PAXWJP5WCPZ7RKRD&quot;&gt;Modern Compiler Design&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.amazon.com/gp/product/0321486811/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321486811&amp;amp;linkCode=as2&amp;amp;tag=russblo0b-20&amp;amp;linkId=GOEGDQG4HIHU56FQ&quot;&gt;Compilers: Principles, Techniques, and Tools (2nd Edition)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;顺便，我正在写一本叫做“Let’s Build A Web Server: First Steps”的书，主要内容是关于怎么从零开始编写一个简单的web服务器。想要先睹为快的话可以点击&lt;a href=&quot;http://ruslanspivak.com/lsbaws-part1/&quot;&gt;这里&lt;/a&gt;，&lt;a href=&quot;http://ruslanspivak.com/lsbaws-part2/&quot;&gt;这里&lt;/a&gt;，和&lt;a href=&quot;http://ruslanspivak.com/lsbaws-part3/&quot;&gt;这里&lt;/a&gt;。想知道这本书的最近更新和出版日期的话，可以到邮件列表里询问。&lt;/p&gt;

</description>
        <pubDate>Mon, 05 Jun 2017 22:56:00 +0800</pubDate>
        <link>https://shiyk.dev/posts/lsbasi-part8/</link>
        <guid isPermaLink="true">https://shiyk.dev/posts/lsbasi-part8/</guid>
        
        <category>Translate</category>
        
        
        <category>posts</category>
        
      </item>
    
      <item>
        <title>一起来写个简单的解释器（7）</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本文是&lt;a href=&quot;https://ruslanspivak.com/&quot;&gt;Ruslan Spivak&lt;/a&gt;的《一起来写个简单的解释器》系列的第7篇（&lt;a href=&quot;http://blog.jobbole.com/95145/&quot;&gt;前6篇&lt;/a&gt;）。&lt;br /&gt;
如果你对kotlin感兴趣，可以参考我的&lt;a href=&quot;https://github.com/shiyk/spi-kotlin/tree/part7&quot;&gt;spi-kotlin&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上一章的末尾提到过，今天我们要学习后续文章的核心数据结构。准备好了吗？Let’s go！&lt;/p&gt;

&lt;p&gt;到现在为止，我们的解释器（interpreter）和分析器（parser）的代码都是合在一起的，每当分析器识别出一个语言结构（比如加、减、乘、除）时，解释器就执行相应的运算。这种解释器称为&lt;strong&gt;语法制导解释器（syntax-directed interpreter)&lt;/strong&gt;。这类解释器通常只遍历一遍输入，用来实现那些基本语法比较合适，但是要分析语法更加复杂的Pascal语言的语言结构，就得借助&lt;strong&gt;中间语言（Intermediate Representation, IR）&lt;/strong&gt;的帮助了。分析器负责构造IR，解释器使用IR来解释输入。&lt;/p&gt;

&lt;p&gt;IR通常使用树结构来表示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part7/lsbasi_part7_realtree.png&quot; alt=&quot;realtree&quot; /&gt;&lt;/p&gt;

&lt;p&gt;先来复习一下关于树的知识点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;树是一种由一个或多个节点按层次组合而成的数据结构。&lt;/li&gt;
  &lt;li&gt;树的顶层节点称为根。&lt;/li&gt;
  &lt;li&gt;除根节点外的所有节点都有唯一的父节点。&lt;/li&gt;
  &lt;li&gt;下图中的 * 是一个父节点。2 和 7 是它的子节点；子节点从左到右排列。&lt;/li&gt;
  &lt;li&gt;没有子节点的节点称为叶子节点。&lt;/li&gt;
  &lt;li&gt;有一个或多个子节点的非根节点称作内部节点。&lt;/li&gt;
  &lt;li&gt;子节点也可以是一个完整的子树。下图中 + 节点的左孩子 * 就是一个有自己的子孙节点的完整子树。&lt;/li&gt;
  &lt;li&gt;在计算机科学中，树通常是倒着画的，根节点在最上方，枝杈则向下生长。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图是表达式 2 * 7 + 3 的树形表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part7/lsbasi_part7_tree_terminology.png&quot; alt=&quot;tree_terminology&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本系列中使用的IR是&lt;strong&gt;抽象语法树（Abstract Syntax Tree, AST）&lt;/strong&gt;。在深入学习抽象语法树之前，我们要先简要的了解一下分析树。虽然我们的解释器和编译器不会用到分析树，不过借助分析树的帮助，能够让你更好的理解分析器是怎么把输入翻译成抽象语法树的。我们还会比较分析树和抽象语法树各自的特点，看看为什么抽象语法树比分析树更适合表示中间语言。&lt;/p&gt;

&lt;p&gt;什么是分析树？分析树（有时也叫具体语法树）是一棵根据语法定义来表示语言的语法结构的树。它展示了分析器是如何识别语言结构的。换句话说，分析树展示了语法的开始符号是怎么扩展成编程语言的具体语句的。&lt;/p&gt;

&lt;p&gt;分析器的调用栈就是一个隐式的分析树，在分析器识别特定语言结构时，它会自动在内存里构造出一棵分析树来。&lt;/p&gt;

&lt;p&gt;下图是表达式 2 * 7 + 3 的语法树：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part7/lsbasi_part7_parsetree_01.png&quot; alt=&quot;parsetree&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分析树记录了分析器用来识别输入的规则序列。&lt;/li&gt;
  &lt;li&gt;分析树的根节点是语法的开始符号。&lt;/li&gt;
  &lt;li&gt;每个内部节点表示一个非终结符，也就是表示一个语法规则，比如 expr, term, factor 等。&lt;/li&gt;
  &lt;li&gt;每个叶子节点表示一个token。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们不会手工构造分析树，也不会把它用在我们的解释器里。不过分析树可以帮助你理解分析器是怎么翻译输入的。&lt;/p&gt;

&lt;p&gt;我写了一个叫做&lt;a href=&quot;https://github.com/rspivak/lsbasi/blob/master/part7/python/genptdot.py&quot;&gt;genptdot.py&lt;/a&gt;的小工具，你可以用它生成表达式的分析树，看看不同的表达式的分析树有什么不同。要使用这个工具你需要先安装&lt;a href=&quot;http://graphviz.org/&quot;&gt;Graphviz&lt;/a&gt;，然后运行下面的命令，工具会把你写在参数里的表达式生成成一张分析树的图片。
&lt;em&gt;用Windows的同学可能得折腾一下Graphviz…&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ python genptdot.py &quot;14 + 2 * 3 - 6 / 2&quot; &amp;gt; \
  parsetree.dot &amp;amp;&amp;amp; dot -Tpng -o parsetree.png parsetree.dot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下图是程序生成的 14 + 2 * 3 - 6 / 2 的分析树：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part7/lsbasi_part7_genptdot_01.png&quot; alt=&quot;genptdot_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用工具生成几个不同表达式的分析树，看看特定表达式的分析树都长什么样子。&lt;/p&gt;

&lt;p&gt;现在我们再来看看抽象语法树(AST)，后续文章里我们会大量使用这种中间语言。它是我们的解释器以及未来的编译器的核心数据结构。&lt;/p&gt;

&lt;p&gt;先来看看表达式 2 * 7 + 3 的抽象语法树和分析树有什么不一样：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part7/lsbasi_part7_ast_01.png&quot; alt=&quot;ast01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上图可以看出，抽象语法树在抓住输入的本质的同时比分析树更小。&lt;/p&gt;

&lt;p&gt;抽象语法树和分析树的区别如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;抽象语法树把操作符/操作作为根节点和中间节点，操作数作为它们的子节点。&lt;/li&gt;
  &lt;li&gt;和分析树不同，抽象语法树不把语法规则表示成中间节点。&lt;/li&gt;
  &lt;li&gt;抽象语法树没有把语法的每个细节都表示出来（这也是“抽象”的来历）。比如，抽象语法树里面没有规则节点和括号。&lt;/li&gt;
  &lt;li&gt;对于同样的语言结构来说，抽象语法树比分析树更加紧凑。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;什么是抽象语法树？抽象语法树是表示语言的抽象语法结构的一棵树，它的每个中间节点和根节点表示一个操作符，这些节点的子节点表示该操作符的操作数。&lt;/p&gt;

&lt;p&gt;之前说过，抽象语法树比分析树更加紧凑。以表达式 7 + ((2 + 3)) 为例，它的抽象语法树比分析树小的多，但仍然保留了输入中的关键信息：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part7/lsbasi_part7_ast_02.png&quot; alt=&quot;ast02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到目前为止还不错，但是在抽象语法树里操作符的优先级怎么表示？在抽象语法树中，要表示操作符的优先级，即“X先于Y发生”，只要把X放在树中比Y低的位置就可以了。之前的图片中的抽象语法树就是这么做的。&lt;/p&gt;

&lt;p&gt;再看几个例子。&lt;/p&gt;

&lt;p&gt;下面的图片中，左边是表达式 2 * 7 + 3 的抽象语法树。现在我们把 7 + 3 放到括号里来改变优先级，右图就是修改后的表达式 2 * (7 + 3) 的抽象语法树。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part7/lsbasi_part7_astprecedence_01.png&quot; alt=&quot;ast_precedence_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面是表达式 1 + 2 + 3 + 4 + 5 的抽象语法树。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part7/lsbasi_part7_astprecedence_02.png&quot; alt=&quot;ast_precedence_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上面的图片里可以看出，优先级更高的操作符处于抽象语法树中更低的位置。&lt;/p&gt;

&lt;p&gt;OK，是时候写点儿代码了。下面我们先实现几个AST节点类型，然后修改分析器，让它生成由这几种节点组成的抽象语法树。&lt;/p&gt;

&lt;p&gt;首先，创建抽象语法树节点的基类 AST，然后从它派生出其他类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class AST(object):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AST类的内容就是这些。AST表示操作符-操作数模型，到目前为止，我们一共有4种操作符，和1种操作数（整型）。操作符有加、减、乘和除。我们可以为每种操作符分别创建一种类型，比如 AddNode, SubNode, MulNode 和 DivNode。不过这样太麻烦了，我们用一种类型BinOp来表示这四种二元操作符（二元操作符是接收两个操作数的操作符）：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class BinOp(AST):
    def __init__(self, left, op, right):
        self.left = left
        self.token = self.op = op
        self.right = right
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BinOp的构造器接收3个参数，其中left和right分别指向节点的左操作数节点和右操作数节点。op保存操作符自身的token：对于加法操作符就是Token(PLUS, ‘+’)，对减法操作符就是Token(MINUS, ‘-‘)，等等。&lt;/p&gt;

&lt;p&gt;要在我们的抽象语法树里表示整型，需要定义一个类Num。Num中保存有INTEGER的token和它的值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Num(AST):
    def __init__(self, token):
        self.token = token
        self.value = token.value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;聪明的读者可能已经注意到了，每个节点都保存了它的token。这主要是为了以后用起来方便。&lt;/p&gt;

&lt;p&gt;再回到表达式 2 * 7 + 3 的例子上来。我们用代码创建它的抽象语法树：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; from spi import Token, MUL, PLUS, INTEGER, Num, BinOp
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; mul_token = Token(MUL, '*')
&amp;gt;&amp;gt;&amp;gt; plus_token = Token(PLUS, '+')
&amp;gt;&amp;gt;&amp;gt; mul_node = BinOp(
...     left=Num(Token(INTEGER, 2)),
...     op=mul_token,
...     right=Num(Token(INTEGER, 7))
... )
&amp;gt;&amp;gt;&amp;gt; add_node = BinOp(
...     left=mul_node,
...     op=plus_token,
...     right=Num(Token(INTEGER, 3))
... )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下图是用我们的新节点类定义的抽象语法树的样子，它的构造过程跟我们上面代码里的构造流程是一样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part7/lsbasi_part7_astimpl_01.png&quot; alt=&quot;astimpl_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面是修改后的分析器代码，它把输入（一个数学表达式）识别成AST对象并返回：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class AST(object):
    pass


class BinOp(AST):
    def __init__(self, left, op, right):
        self.left = left
        self.token = self.op = op
        self.right = right


class Num(AST):
    def __init__(self, token):
        self.token = token
        self.value = token.value


class Parser(object):
    def __init__(self, lexer):
        self.lexer = lexer
        # set current token to the first token taken from the input
        self.current_token = self.lexer.get_next_token()

    def error(self):
        raise Exception('Invalid syntax')
    
    def eat(self, token_type):
        # compare the current token type with the passed token
        # type and if they match then &quot;eat&quot; the current token
        # and assign the next token to the self.current_token,
        # otherwise raise an exception.
        if self.current_token.type == token_type:
            self.current_token = self.lexer.get_next_token()
        else:
            self.error()
    
    def factor(self):
        &quot;&quot;&quot;factor : INTEGER | LPAREN expr RPAREN&quot;&quot;&quot;
        token = self.current_token
        if token.type == INTEGER:
            self.eat(INTEGER)
            return Num(token)
        elif token.type == LPAREN:
            self.eat(LPAREN)
            node = self.expr()
            self.eat(RPAREN)
            return node
    
    def term(self):
        &quot;&quot;&quot;term : factor ((MUL | DIV) factor)*&quot;&quot;&quot;
        node = self.factor()
    
        while self.current_token.type in (MUL, DIV):
            token = self.current_token
            if token.type == MUL:
                self.eat(MUL)
            elif token.type == DIV:
                self.eat(DIV)
    
            node = BinOp(left=node, op=token, right=self.factor())
    
        return node
    
    def expr(self):
        &quot;&quot;&quot;
        expr   : term ((PLUS | MINUS) term)*
        term   : factor ((MUL | DIV) factor)*
        factor : INTEGER | LPAREN expr RPAREN
        &quot;&quot;&quot;
        node = self.term()
    
        while self.current_token.type in (PLUS, MINUS):
            token = self.current_token
            if token.type == PLUS:
                self.eat(PLUS)
            elif token.type == MINUS:
                self.eat(MINUS)
    
            node = BinOp(left=node, op=token, right=self.term())
    
        return node
    
    def parse(self):
        return self.expr()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回顾一下为数学表达式构造AST结构的过程。&lt;/p&gt;

&lt;p&gt;从分析器的代码里可以看出，分析器构建AST节点的方法是，每个BinOp节点将当前变量的值作为它的左子节点，term或factor的调用结果作为它的右子节点。从效果上看，解析器是在把节点往左下方推，表达式 1 + 2 + 3 + 4 + 5 的抽象语法树就是一个很好的例子。下图是分析器构造该语法树的过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part7/lsbasi_part7_astimpl_02.png&quot; alt=&quot;astimpl_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我写了一个可以可视化不同数学表达式的AST的小工具，它从第一个参数里读取数学表达式，并生成相应的DOT文件，然后用dot工具生成实际的AST图像（dot是Graphviz包的一部分，要运行dot命令你需要先安装Graphviz）。下面是生成表达式 7 + 3 * (10 / (12 / (3 + 1) - 1)) 的AST图像的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ python genastdot.py &quot;7 + 3 * (10 / (12 / (3 + 1) - 1))&quot; &amp;gt; \
  ast.dot &amp;amp;&amp;amp; dot -Tpng -o ast.png ast.dot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part7/lsbasi_part7_genastdot_01.png&quot; alt=&quot;genastdot_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;写几个数学表达式，手工画出它的抽象语法树，然后跟&lt;a href=&quot;https://github.com/rspivak/lsbasi/blob/master/part7/python/genastdot.py&quot;&gt;genastdot.py&lt;/a&gt;工具生成的抽象语法树对比验证一下。这能帮你更好的理解分析器是怎样构建不同的数学表达式的抽象语法树的。&lt;/p&gt;

&lt;p&gt;Ok，这是表达式 2 * 7 + 3 的抽象语法树：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part7/lsbasi_part7_ast_walking_01.png&quot; alt=&quot;ast_walking_01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你会如何遍历这棵树，来计算它表示的表达式的值？答案是后序遍历——深度优先遍历的一种特殊形式。后序遍历从根节点开始，从左到右递归地遍历每个节点的子节点。后序遍历尽可能快地遍历离根节点最远的节点。&lt;/p&gt;

&lt;p&gt;下面是后续遍历的伪代码，其中«postorder actions»是操作占位符，对于BinOp节点就是加减乘除，对于Num节点就是简单地返回它的整型值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part7/lsbasi_part7_ast_visit_postorder.png&quot; alt=&quot;ast_visit_postorder&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用后序遍历的原因是：首先，我们应该先计算树中更靠下的中间节点，因为它们代表优先级更高的操作符；其次，在执行一个操作符的操作前，我们得先计算它的操作数的值。从下图可以看到，根据后序遍历，我们先计算表达式 2 * 7 的值，然后才能计算 14 + 3，最终得到正确结果 17：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part7/lsbasi_part7_ast_walking_02.png&quot; alt=&quot;ast_walking_02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完整地说，一共有3种深度优先遍历：前序遍历，中序遍历，后序遍历。它们的名字来源于遍历代码中操作的位置：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part7/lsbasi_part7_ast_visit_generic.png&quot; alt=&quot;ast_visit_generic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有时候你在3个位置（前序，中序，后序）都需要执行操作。这篇文章的repository里就有这样的例子。&lt;/p&gt;

&lt;p&gt;OK，现在让我们用代码遍历并翻译分析器生成的抽象语法树吧。
Here is the source code that implements the Visitor pattern:
下面是&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F&quot;&gt;访问者模式&lt;/a&gt;的实现代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class NodeVisitor(object):
    def visit(self, node):
        method_name = 'visit_' + type(node).__name__
        visitor = getattr(self, method_name, self.generic_visit)
        return visitor(node)

    def generic_visit(self, node):
        raise Exception('No visit_{} method'.format(type(node).__name__))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是我们的翻译器类的实现代码。它继承了NodeVisitor类，实现了形如visit_NodeType的访问方法，其中NodeType是BinOp、Num等节点类的名字：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;class Interpreter(NodeVisitor):
    def __init__(self, parser):
        self.parser = parser

    def visit_BinOp(self, node):
        if node.op.type == PLUS:
            return self.visit(node.left) + self.visit(node.right)
        elif node.op.type == MINUS:
            return self.visit(node.left) - self.visit(node.right)
        elif node.op.type == MUL:
            return self.visit(node.left) * self.visit(node.right)
        elif node.op.type == DIV:
            return self.visit(node.left) / self.visit(node.right)
    
    def visit_Num(self, node):
        return node.value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于这段代码，值得一提的有两点：首先，操作AST节点的代码与AST节点本身是分离的。你可以看到所有AST节点类（BinOp和Num）都没有提供操作其中数据的代码。访问逻辑封装在实现了NodeVisitor的Interpreter类中。&lt;/p&gt;

&lt;p&gt;其次，NodeVisitor的访问方法没有像下面这样用一大坨if语句来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def visit(node):
    node_type = type(node).__name__
    if node_type == 'BinOp':
        return self.visit_BinOp(node)
    elif node_type == 'Num':
        return self.visit_Num(node)
    elif ...
    # ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;def visit(node):
    if isinstance(node, BinOp):
        return self.visit_BinOp(node)
    elif isinstance(node, Num):
        return self.visit_Num(node)
    elif ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NodeVisitor的访问方法很通用地根据参数的类型将调用分发到了相应的方法。前面提到，为了确保这一点，我们的翻译器继承了NodeVisitor类，并实现了必要的方法。如果传给visit方法的参数是BinOp类型，visit方法会把调用分发到visit_BinOp方法，如果节点了类型是Num，visit方法就会把调用分发到visit_Num方法，等等。&lt;/p&gt;

&lt;p&gt;花点时间研究一下这种方法（Python的标准模块ast也是用了同样的机制进行节点遍历），为了我们会给解释器添加许多新的visit_NodeType方法。&lt;/p&gt;

&lt;p&gt;generic_visit是一个fallback，它抛出一个异常，表明翻译器遇到了一个还没有实现相应的visit_NodeType方法的节点。&lt;/p&gt;

&lt;p&gt;现在，我们手动构造一个表达式 2 * 7 + 3 的AST对象，把它传给解释器，看看visit方法能不能得到表达式的正确结果。在Python shell里执行下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; from spi import Token, MUL, PLUS, INTEGER, Num, BinOp
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; mul_token = Token(MUL, '*')
&amp;gt;&amp;gt;&amp;gt; plus_token = Token(PLUS, '+')
&amp;gt;&amp;gt;&amp;gt; mul_node = BinOp(
...     left=Num(Token(INTEGER, 2)),
...     op=mul_token,
...     right=Num(Token(INTEGER, 7))
... )
&amp;gt;&amp;gt;&amp;gt; add_node = BinOp(
...     left=mul_node,
...     op=plus_token,
...     right=Num(Token(INTEGER, 3))
... )
&amp;gt;&amp;gt;&amp;gt; from spi import Interpreter
&amp;gt;&amp;gt;&amp;gt; inter = Interpreter(None)
&amp;gt;&amp;gt;&amp;gt; inter.visit(add_node)
17
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如你所见，我把表达式的根节点传给了visit方法，visit方法通过把调用分发给Interpreter类中正确的方法（visit_BinOp和visit_Num）触发遍历并生成计算结果。&lt;/p&gt;

&lt;p&gt;OK，下面是我们的新翻译器的完整代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;&quot;&quot;&quot; SPI - Simple Pascal Interpreter &quot;&quot;&quot;

###############################################################################
#                                                                             #
#  LEXER                                                                      #
#                                                                             #
###############################################################################

# Token types
#
# EOF (end-of-file) token is used to indicate that
# there is no more input left for lexical analysis
INTEGER, PLUS, MINUS, MUL, DIV, LPAREN, RPAREN, EOF = (
    'INTEGER', 'PLUS', 'MINUS', 'MUL', 'DIV', '(', ')', 'EOF'
)


class Token(object):
    def __init__(self, type, value):
        self.type = type
        self.value = value

    def __str__(self):
        &quot;&quot;&quot;String representation of the class instance.
    
        Examples:
            Token(INTEGER, 3)
            Token(PLUS, '+')
            Token(MUL, '*')
        &quot;&quot;&quot;
        return 'Token({type}, {value})'.format(
            type=self.type,
            value=repr(self.value)
        )
    
    def __repr__(self):
        return self.__str__()


class Lexer(object):
    def __init__(self, text):
        # client string input, e.g. &quot;4 + 2 * 3 - 6 / 2&quot;
        self.text = text
        # self.pos is an index into self.text
        self.pos = 0
        self.current_char = self.text[self.pos]

    def error(self):
        raise Exception('Invalid character')
    
    def advance(self):
        &quot;&quot;&quot;Advance the `pos` pointer and set the `current_char` variable.&quot;&quot;&quot;
        self.pos += 1
        if self.pos &amp;gt; len(self.text) - 1:
            self.current_char = None  # Indicates end of input
        else:
            self.current_char = self.text[self.pos]
    
    def skip_whitespace(self):
        while self.current_char is not None and self.current_char.isspace():
            self.advance()
    
    def integer(self):
        &quot;&quot;&quot;Return a (multidigit) integer consumed from the input.&quot;&quot;&quot;
        result = ''
        while self.current_char is not None and self.current_char.isdigit():
            result += self.current_char
            self.advance()
        return int(result)
    
    def get_next_token(self):
        &quot;&quot;&quot;Lexical analyzer (also known as scanner or tokenizer)
    
        This method is responsible for breaking a sentence
        apart into tokens. One token at a time.
        &quot;&quot;&quot;
        while self.current_char is not None:
    
            if self.current_char.isspace():
                self.skip_whitespace()
                continue
    
            if self.current_char.isdigit():
                return Token(INTEGER, self.integer())
    
            if self.current_char == '+':
                self.advance()
                return Token(PLUS, '+')
    
            if self.current_char == '-':
                self.advance()
                return Token(MINUS, '-')
    
            if self.current_char == '*':
                self.advance()
                return Token(MUL, '*')
    
            if self.current_char == '/':
                self.advance()
                return Token(DIV, '/')
    
            if self.current_char == '(':
                self.advance()
                return Token(LPAREN, '(')
    
            if self.current_char == ')':
                self.advance()
                return Token(RPAREN, ')')
    
            self.error()
    
        return Token(EOF, None)


###############################################################################
#                                                                             #
#  PARSER                                                                     #
#                                                                             #
###############################################################################

class AST(object):
    pass


class BinOp(AST):
    def __init__(self, left, op, right):
        self.left = left
        self.token = self.op = op
        self.right = right


class Num(AST):
    def __init__(self, token):
        self.token = token
        self.value = token.value


class Parser(object):
    def __init__(self, lexer):
        self.lexer = lexer
        # set current token to the first token taken from the input
        self.current_token = self.lexer.get_next_token()

    def error(self):
        raise Exception('Invalid syntax')
    
    def eat(self, token_type):
        # compare the current token type with the passed token
        # type and if they match then &quot;eat&quot; the current token
        # and assign the next token to the self.current_token,
        # otherwise raise an exception.
        if self.current_token.type == token_type:
            self.current_token = self.lexer.get_next_token()
        else:
            self.error()
    
    def factor(self):
        &quot;&quot;&quot;factor : INTEGER | LPAREN expr RPAREN&quot;&quot;&quot;
        token = self.current_token
        if token.type == INTEGER:
            self.eat(INTEGER)
            return Num(token)
        elif token.type == LPAREN:
            self.eat(LPAREN)
            node = self.expr()
            self.eat(RPAREN)
            return node
    
    def term(self):
        &quot;&quot;&quot;term : factor ((MUL | DIV) factor)*&quot;&quot;&quot;
        node = self.factor()
    
        while self.current_token.type in (MUL, DIV):
            token = self.current_token
            if token.type == MUL:
                self.eat(MUL)
            elif token.type == DIV:
                self.eat(DIV)
    
            node = BinOp(left=node, op=token, right=self.factor())
    
        return node
    
    def expr(self):
        &quot;&quot;&quot;
        expr   : term ((PLUS | MINUS) term)*
        term   : factor ((MUL | DIV) factor)*
        factor : INTEGER | LPAREN expr RPAREN
        &quot;&quot;&quot;
        node = self.term()
    
        while self.current_token.type in (PLUS, MINUS):
            token = self.current_token
            if token.type == PLUS:
                self.eat(PLUS)
            elif token.type == MINUS:
                self.eat(MINUS)
    
            node = BinOp(left=node, op=token, right=self.term())
    
        return node
    
    def parse(self):
        return self.expr()


###############################################################################
#                                                                             #
#  INTERPRETER                                                                #
#                                                                             #
###############################################################################

class NodeVisitor(object):
    def visit(self, node):
        method_name = 'visit_' + type(node).__name__
        visitor = getattr(self, method_name, self.generic_visit)
        return visitor(node)

    def generic_visit(self, node):
        raise Exception('No visit_{} method'.format(type(node).__name__))


class Interpreter(NodeVisitor):
    def __init__(self, parser):
        self.parser = parser

    def visit_BinOp(self, node):
        if node.op.type == PLUS:
            return self.visit(node.left) + self.visit(node.right)
        elif node.op.type == MINUS:
            return self.visit(node.left) - self.visit(node.right)
        elif node.op.type == MUL:
            return self.visit(node.left) * self.visit(node.right)
        elif node.op.type == DIV:
            return self.visit(node.left) / self.visit(node.right)
    
    def visit_Num(self, node):
        return node.value
    
    def interpret(self):
        tree = self.parser.parse()
        return self.visit(tree)


def main():
    while True:
        try:
            try:
                text = raw_input('spi&amp;gt; ')
            except NameError:  # Python3
                text = input('spi&amp;gt; ')
        except EOFError:
            break
        if not text:
            continue

        lexer = Lexer(text)
        parser = Parser(lexer)
        interpreter = Interpreter(parser)
        result = interpreter.interpret()
        print(result)


if __name__ == '__main__':
    main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把上面的代码保存为spi.py，或直接从&lt;a href=&quot;https://github.com/rspivak/lsbasi/blob/master/part7/python/spi.py&quot;&gt;GitHub&lt;/a&gt;下载。运行试试，看看基于树的新翻译器能不能正确地计算出数学表达式的结果。&lt;/p&gt;

&lt;p&gt;下面是一些示例测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ python spi.py
spi&amp;gt; 7 + 3 * (10 / (12 / (3 + 1) - 1))
22
spi&amp;gt; 7 + 3 * (10 / (12 / (3 + 1) - 1)) / (2 + 3) - 5 - 3 + (8)
10
spi&amp;gt; 7 + (((3 + 2)))
12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今天你学到了分析树、抽象语法树，学到了怎样构造和遍历抽象语法树，怎样翻译抽象语法树表示的输入。你还修改并分离了分析器和翻译器。现在分词器、分析器和翻译器之间的接口是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part7/lsbasi_part7_pipeline.png&quot; alt=&quot;pipeline&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这张图可以读作“分析器从分词器中得到token，将生成的AST返回给翻译器，翻译器使用AST遍历并翻译输入”。&lt;/p&gt;

&lt;p&gt;今天的内容就到这里了。不过在合上书本之前，我还想再说一说递归下降分析器，给它下一个准确的定义，因为我在上一章里说过我会更详细的介绍它。递归下降分析器是一种自上而下的分析器，它使用一系列的递归过程处理输入。自上而下说明分析器从从根节点开始构建分析树，然后逐步构造更低层的节点。&lt;/p&gt;

&lt;p&gt;然后就是练习时间了 :)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lsbasi-part7/lsbasi_part7_exercise.png&quot; alt=&quot;exercise&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;编写一个翻译器（提示：node visitor），输入一个数学表达式，并以后缀表达式（也就是逆波兰表达式，RPN）的形式输出它。例如，如果翻译器的输入是 (5 + 3) * 12 / 3，那么输出应该是 5 3 + 12 * 3 /。答案在&lt;a href=&quot;https://github.com/rspivak/lsbasi/blob/master/part7/python/ex1.py&quot;&gt;这里&lt;/a&gt;，不过一点先自己尝试解决再看答案。&lt;/li&gt;
  &lt;li&gt;编写一个翻译器（node visitor），输入一个数学表达式，并以LISP风格输出它，也就是 2 + 3 应该变成 (+ 2 3)，(2 + 3 * 5) 应该变成(+ 2 (* 3 5))。答案可以在&lt;a href=&quot;https://github.com/rspivak/lsbasi/blob/master/part7/python/ex2.py&quot;&gt;这里&lt;/a&gt;找到，不过还是那句话，看答案之前先自己试着解决一下。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下篇文章里，我们会给我们成长中的Pascal解释器增加赋值和一元运算。最后，祝你身体健康，再见。&lt;/p&gt;

&lt;p&gt;P.S. 我还提供了一个翻译器的Rust实现，你可以在&lt;a href=&quot;https://github.com/rspivak/lsbasi/blob/master/part7/rust/spi/src/main.rs&quot;&gt;GitHub&lt;/a&gt;上找到它。我写这个版本是为了学习Rust，所以代码里可能会有一些不那么“理想”的地方。欢迎提出评论和建议，来帮助改善这些代码。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;译者的kotlin版本也是为了同样的目的写的，欢迎大家批评指正&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;下面是我推荐的一些书籍列表，它们对你学习解释器和编译器有帮助：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.com/gp/product/193435645X/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=193435645X&amp;amp;linkCode=as2&amp;amp;tag=russblo0b-20&amp;amp;linkId=MP4DCXDV6DJMEJBL&quot;&gt;Language Implementation Patterns: Create Your Own Domain-Specific and General Programming Languages (Pragmatic Programmers)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.amazon.com/gp/product/0470177071/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0470177071&amp;amp;linkCode=as2&amp;amp;tag=russblo0b-20&amp;amp;linkId=UCLGQTPIYSWYKRRM&quot;&gt;Writing Compilers and Interpreters: A Software Engineering Approach&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.amazon.com/gp/product/052182060X/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=052182060X&amp;amp;linkCode=as2&amp;amp;tag=russblo0b-20&amp;amp;linkId=ZSKKZMV7YWR22NMW&quot;&gt;Modern Compiler Implementation in Java&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.amazon.com/gp/product/1461446988/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=1461446988&amp;amp;linkCode=as2&amp;amp;tag=russblo0b-20&amp;amp;linkId=PAXWJP5WCPZ7RKRD&quot;&gt;Modern Compiler Design&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.amazon.com/gp/product/0321486811/ref=as_li_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=0321486811&amp;amp;linkCode=as2&amp;amp;tag=russblo0b-20&amp;amp;linkId=GOEGDQG4HIHU56FQ&quot;&gt;Compilers: Principles, Techniques, and Tools (2nd Edition)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;顺便，我正在写一本叫做“Let’s Build A Web Server: First Steps”的书，主要内容是关于怎么从零开始编写一个简单的web服务器。想要先睹为快的话可以点击&lt;a href=&quot;http://ruslanspivak.com/lsbaws-part1/&quot;&gt;这里&lt;/a&gt;，&lt;a href=&quot;http://ruslanspivak.com/lsbaws-part2/&quot;&gt;这里&lt;/a&gt;，和&lt;a href=&quot;http://ruslanspivak.com/lsbaws-part3/&quot;&gt;这里&lt;/a&gt;。想知道这本书的最近更新和出版日期的话，可以到邮件列表里询问。&lt;/p&gt;
</description>
        <pubDate>Sun, 29 Jan 2017 23:34:00 +0800</pubDate>
        <link>https://shiyk.dev/posts/lsbasi-part7/</link>
        <guid isPermaLink="true">https://shiyk.dev/posts/lsbasi-part7/</guid>
        
        <category>Translate</category>
        
        
        <category>posts</category>
        
      </item>
    
  </channel>
</rss>
